# Bash commands

- npm run build - Build the project
- npm run typecheck - Run the typechecker
- npm run test - Run tests
- npm run db:migrate:make (name_of_migration) - Generate a new database migration
- npm run db:migrate:latest - Apply all new migrations
- npm run db:migrate:up - Apply next migration
- npm run db:migrate:down - Rollback last migration
- npm run db:typegen - Regenerate database schema types using Kanel (reads directly from the database)
- npx shadcn@latest add {component_name} - Install a UI component from shadcn (see https://ui.shadcn.com/docs/components for latest list of components)

# Tech stack

- Database: PostgreSQL
- Database client: Kysely for building SQL queries with Kanel for generating TS types from db structure
- Web framework: Next.js with React front end
- Queries/mutations: React Query
- UI components: shadcn
- Icons: Lucide
- Payments: Stripe
- CSS: Tailwind with tailwind-typography and tw-animate-css plugins
- User authentication: Auth.js
- Analytics: PostHog
- Logging: tslog
- Email: Loops (marketing) and Resend (transactional)
- Testing: Vitest
- Error reporting: Sentry
- Deployment: Vercel

# Code style

- Use ES modules (import/export) syntax, not CommonJS (require)
- Destructure imports when possible (eg. import { foo } from 'bar')
- Import static image assets into components instead of saving them in /public and referencing them with static strings
- All file and directory names should be in kebab case

# Workflow

- Be sure to typecheck when youâ€™re done making a series of code changes
- Prefer running single tests, and not the whole test suite, for performance

# Structure

- /app: Next.js app router pages and routes
- /application: Domain and business logic, both for back end and front end
  - /api.client.ts: API intended to be executed on the browser
  - /api.server.ts: API intended to be executed on the server
- /public: Public files hosted at the web app root
- /scripts: Housekeeping and other maintenance scripts
- /services: Logic shared across concerns in /application, external integrations, common UI components, etc.
  - /db/schemas: Database schema types generated by Kanel via npm run db:typegen
  - /db/migrations: Database migrations generated by kysely-ctl via npm run db:migration:create
- /types: Global utility types

## /application and /services

- /application and /services are the main directories where the app's logic live, but they have different roles.
  - /application holds domain and business logic modules. Anything that you would think of as a feature should generally go within a subdirectory under /application.
  - /services holds APIs for external integrations, infrastructure, and common components shared across units used in /application and the rest of the app. Anything that you would think of as being an underlying dependency for features should generally go within a subdirectory under /services.
- Each module or subdirectory under /application and /services shares a common structure:
  - api.\*.ts: API for accessing the module, organized by the intended environment (e.g., client, server, edge)
  - api.\*/: (Alternative to api.\*.ts) directory containing files for the module's API, organized by the intended environment and accessible from index.ts
  - init.\*.ts: One-time setup script for a module, organized by the intended environment
  - components/\*.tsx: React components related to the module
  - hooks/\*.ts: React hooks related to the module
  - Subdirectories represent submodules and have a structure similar to their parents
  - Every file and directory listed above is optional

# Auth

- Most top-level resources are gated by entity rather than user. Users have multiple entities, and at any given time only one entity is "current" in the user's session. Users may switch between entities.
- The canonical way to check whether a user is authorized to use a top-level resource is to compare the current user's current entity ID to the entity ID of the resource. Use getCurrentEntity from /services/auth/api.server.ts to get the current entity ID: const { id } = await getCurrentEntity();
- Sub-level resources can be authorized by using SQL joins.

# DB queries

- Write database queries using Kysely's query builder.
- When updating a table, check to see whether it has an updated_at column. If it does, update the updated_at column with a timestamp using Kysely's sql function: `` sql`now()` ``

# DB migrations

- To generate a migration scaffold, run: npm run db:migrate:make name_of_migration, where you replace name_of_migration with something appropriate to the physical change you're making to the database.
  - Migrations are created in /services/db/migrations
- After generating the migration scaffold, edit the file as needed.
  - Fill out the up and down portions of the migration.
  - The sequence of actions in the down migration should be the inverse of actions in the up migration.
  - Study previous migrations for examples.
- All tables should have an auto-generated id primary key, a created_at timestamp column, and an updated_at column.
  - Use the following code to generate an auto-generated primary key: `` .addColumn("id", "text", (col) => col.primaryKey().defaultTo(sql`nanoid()`).notNull()) ``
  - Use the following code to generate a created_at timestamp column: `` .addColumn("created_at", "timestampz", (col) => col.defaultTo(sql`now()`).notNull()) ``
  - Use the following code to generate an updated_at timestamp column: `` .addColumn("updated_at", "timestampz", (col) => col.defaultTo(sql`now()`).notNull()) ``
  - EXCEPTION: join tables don't need id, created_at, or updated_at columns. Tables with natural keys or composite keys don't need an auto-generated primary key.
- Don't use UUID or auto-incrementing sequences for primary key ids, always use nanoid().
- Once you're done creating your migration, execute it.
- Once you've successfully executed your migration, regenerate schema types.
  - Generated schema types are found in /services/db/schemas
- Once you've regenerated schema types, do a typecheck on the whole project. Fix any errors due to updated types.

# Front end components

- DO NOT use a top-level /components directory. Create all components within modules under /application/\*/components and /services/\*/components. If you're unsure of where to place a component, ask for clarification.
- If you need to add a front end component to create a feature but there isn't an appropriate module under /application or /services, consider creating a new one, or creating a submodule. Refactor when necessary.
- Prefer installing and composing basic UI components from shadcn over creating new ones from scratch.
  - NOTE: The feature-oriented directory structure of this project isn't always compatible with shadcn's assumptions. After installing a UI component from shadcn, make sure that all new files are located under /services/ui.
